### 越用越熟练的电脑操作 Agent

#### 实验目的

本实验将外部化学习方法应用于电脑操作场景，构建一个能够从经验中学习、越用越熟练的浏览器自动化 Agent。这种从"思考执行"到"直接回放"的转变，是外部化学习实现能力固化的典型体现——**将重复性流程从模型的临时推理中"解放"出来，转化为独立的、可精确执行的外部程序**。

#### 背景知识

**外部化学习的核心思想**：传统的 Agent 依赖上下文学习(in-context learning)或参数记忆(parametric memory)——通过在提示词中提供示例，或依赖模型训练时学到的知识。但这两种方式都存在局限：上下文学习受限于上下文窗口大小，参数记忆无法动态更新。外部化学习则采用了完全不同的策略——将 Agent 的经验和技能存储在外部的、可编辑的知识库中。

**Voyager 的"探索-沉淀-复用"范式**：Voyager 是一个在 Minecraft 游戏中自主探索的 Agent 系统，它展示了外部化学习的强大潜力。其工作流程包含三个关键阶段：

1. 探索阶段：Agent 通过与环境交互完成任务，如"建造一个工作台"。在这个过程中，它通过多轮推理决定执行哪些游戏操作，并最终成功完成任务。

2. 沉淀阶段：一旦任务成功，Voyager 会将整个操作序列"蒸馏"为一段可执行的 JavaScript 代码，命名为一个技能函数(如 `craftWorkbench()`)。这段代码包含了完成该任务的所有必要步骤，并存储到外部的技能库中。关键在于，这段代码是独立的、可直接执行的，不需要模型重新推理。

3. 复用阶段：当面对新任务时(如"建造一个木剑，需要先有工作台")，Voyager 会检索技能库，发现已经有 `craftWorkbench()` 这个技能。它可以直接调用这个函数，而不是重新推理如何建造工作台。这种复用大幅提高了效率和稳定性。

这种范式的核心价值在于"能力固化"——将一次性的、临时的推理过程转化为永久的、可复用的能力单元。

#### 实验内容描述

本实验将上述外部化学习方法应用于浏览器自动化场景。当前的电脑操作 Agent 每次执行任务时都需要通过多模态大模型进行完整的视觉推理，即使之前成功完成过完全相同的任务也必须重新推理。本实验的目标是让 Agent 能够从经验中学习，将成功的网页操作流程"沉淀"为可回放的工作流，在后续执行相似任务时直接复用。

**问题背景**：当前的电脑操作 Agent 每次执行任务（如网页浏览、表单填写）时，都需要通过多模态大模型进行完整的视觉推理——观察屏幕截图、决定点击位置、输入文本。即使之前成功完成过完全相同的任务，Agent 也无法利用这些经验，必须重新推理。这种方式存在三个问题：效率低下（每次都需要多次昂贵的 LLM 调用）、不稳定（LLM 的随机性导致操作路径不一致）、成本高昂（大量视觉理解调用）。本质上，这是因为 Agent 依赖上下文学习或参数记忆，而没有将成功经验外部化为可复用的工具。

**实验目标**：构建一个具有学习能力的电脑操作 Agent，使其能够：
- 在首次执行任务时，通过多模态大模型的推理完成操作，同时捕获稳定的操作流程
- 将成功的操作流程以基于稳定选择器（如 XPath、CSS Selector）的形式存储到知识库
- 在后续执行相似任务时，能够识别任务的相似性，从知识库中检索匹配的工作流
- 直接回放工作流中的操作步骤，无需再次调用大模型逐步推理，从而实现快速、稳定的执行

**技术方案**：实验基于 browser-use 框架进行二次开发。Browser-use 提供了与 Playwright 集成的浏览器自动化能力，并且在与多模态 LLM 交互时，为页面上的可交互元素分配临时编号。当 LLM 输出操作指令（如 `click(13)`、`type(7， "example@email.com")`）后，browser-use 会创建 DOMHistoryElement 对象记录该元素的详细信息，包括 XPath、CSS Selector、元素类型、文本内容等。实验的核心任务是利用这些信息实现学习和回放机制。

**学习阶段的实现**（对应"探索-沉淀"阶段）：当 Agent 首次执行任务时，系统处于"学习模式"。在首次完成网页操作时捕获完整的操作流程：
- Agent 通过多模态大模型的观察-思考-行动循环完成任务。每次 LLM 决定执行一个操作（点击、输入等），系统从 browser-use 的内部状态中提取被操作元素的稳定标识符（优先使用 XPath，因为它对页面结构微小变化更具鲁棒性）。
- 将每一步操作记录为一个结构化的步骤，包含：操作类型（click、type、select 等）、目标元素的 XPath、相关参数（如输入的文本内容）、执行后的状态验证信息（如页面 URL 变化、特定元素出现）。这将动作序列转化为可回放的结构化数据。
- 当任务成功完成后，系统提示 LLM 为这个任务生成一个语义标签和描述。语义标签是任务意图的抽象表达（如"发送电子邮件"），描述则包含任务的关键要素（如"收件人字段、主题字段、内容字段、发送按钮"）。这些信息将用于未来的任务匹配。
- 将步骤序列、语义标签、描述一起存储到知识库中，形成一个"工作流"（workflow）条目。这个工作流就是外部化的、可复用的操作能力。

**应用阶段的实现**（对应"检索-复用"阶段）：当 Agent 接收到新任务时，系统首先尝试从知识库中检索匹配的工作流。匹配机制结合语义相似度（比较新任务描述与存储的工作流描述的嵌入向量相似度）和关键要素检查（新任务是否涉及相似的操作对象和目标）。如果找到匹配度超过阈值的工作流，Agent 进入"回放模式"——这正是外部化学习带来的效率飞跃：
- 按照工作流中记录的步骤顺序，逐步执行操作。由于现代网页是动态加载的，直接连续执行会导致失败（目标元素可能尚未加载）。因此，在执行每一步之前，必须使用 Playwright 的等待机制（如 `page.locator(xpath).wait_for(state='visible'， timeout=15000)`）确保目标元素已加载且可交互。
- 对于包含参数的操作（如输入文本），工作流中存储的是参数化的模板（如"在收件人字段输入 `{{email}}`"）。回放时，需要从当前任务的指令中提取实际参数值（如"test@example.com"），并填充到模板中。这个参数提取可以通过简单的 LLM 调用完成，但不需要完整的视觉推理，从而大幅降低成本。
- 如果工作流回放过程中某一步失败（如找不到目标元素、等待超时），说明网页结构可能发生了变化，存储的工作流已过时。此时，Agent 应该记录这次失败，将该工作流标记为"可能过时"，并退回到学习模式，重新通过 LLM 推理来完成任务，同时生成新的工作流替换旧的。这体现了持续迭代改进的机制。

**验收场景与指标**：选择一个具体的网页操作任务进行验收，例如在 Gmail 网页版中发送邮件。

首次执行（学习阶段）：
- **任务指令**："给 test@example.com 发送一封邮件，主题是'测试邮件'，内容是'这是一封测试邮件，用于验证 Agent 学习功能'"
- **观察与记录**：演示 Agent 如何通过多模态 LLM 观察 Gmail 界面，识别"撰写"按钮并点击，识别收件人输入框并输入邮箱地址，识别主题和内容输入框并填写，识别"发送"按钮并点击。记录整个过程的操作步骤、耗时、LLM 调用次数。
- **工作流生成**：展示生成的工作流，包含每一步的 XPath、操作类型、参数。

重复执行（应用阶段）：
- **任务指令**："给 another@example.com 发送邮件，主题是'后续测试'，内容是'这是第二封测试邮件'"
- **工作流匹配**：演示系统如何识别新任务与存储的"发送邮件"工作流匹配，提取新的参数值（收件人、主题、内容）。
- **快速回放**：展示 Agent 直接执行工作流中的步骤，无需 LLM 进行视觉推理。每一步只需要等待元素加载、执行操作，整个过程应显著快于首次执行。
- **性能对比**：记录第二次执行的耗时、LLM 调用次数，与首次执行对比。

**知识更新**：
- 在重复执行的应用阶段，模拟网页改版场景（如手动修改测试页面的 HTML 结构，使某个按钮的 XPath 发生变化），验证 Agent 能否检测到工作流失效，并回退到学习阶段。
- 演示 Agent 如何在检测到失效后，重新学习新的工作流，更新知识库，并在下次执行时使用新工作流。